{% extends "base.html" %}

{% block content %}
    <!-- Chat Screen Template -->
    <div id="chat-screen-template">
        <div class="chat-screen-container">
            <header class="chat-header">
                <a href="{{ url_for('index') }}" class="back-btn">‚Üê Back</a>
                <div class="chat-info">
                    <h2 id="current-chat-with">Chat with {{ other_user.username }}</h2>
                    <span id="current-chat-status" class="chat-status"></span>
                </div>
                <div id="user-activity-indicator" class="user-activity-indicator" style="display: none;"></div>
                <button id="delete-conversation-btn" class="delete-btn">Delete Chat</button>
            </header>
            
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be loaded here -->
                <div class="empty-chat">
                    <p>No messages yet. Start the conversation!</p>
                </div>
            </div>
            
            <div class="chat-input-container">
                <div class="input-group">
                    <button id="mic-btn" class="mic-btn">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 1C11.2044 1 10.4413 1.31607 9.87868 1.87868C9.31607 2.44129 9 3.20435 9 4V12C9 12.7956 9.31607 13.5587 9.87868 14.1213C10.4413 14.6839 11.2044 15 12 15C12.7956 15 13.5587 14.6839 14.1213 14.1213C14.6839 13.5587 15 12.7956 15 12V4C15 3.20435 14.6839 2.44129 14.1213 1.87868C13.5587 1.31607 12.7956 1 12 1Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M19 10V12C19 13.8565 18.2625 15.637 16.9497 16.9497C15.637 18.2625 13.8565 19 12 19C10.1435 19 8.36301 18.2625 7.05025 16.9497C5.7375 15.637 5 13.8565 5 12V10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 19V23" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 23H16" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                    <input type="text" id="message-input" placeholder="Type your message...">
                    <button id="send-btn">‚û§</button>
                </div>
                <div class="audio-controls" id="audio-controls" style="display: none;">
                    <span id="recording-status">Recording... <span id="recording-timer">0s</span></span>
                    <button id="stop-recording-btn" class="stop-btn">‚û§</button>
                </div>
            </div>
            
            <!-- Offline Status Indicator -->
            <div id="offline-indicator" class="offline-indicator" style="display: none;">
                <span>üì° Offline - Messages will be sent when connection is restored</span>
            </div>
        </div>
    </div>
    
    <!-- Hidden field for VAPID public key -->
    <input type="hidden" id="vapid-public-key" value="{{ vapid_public_key }}">
    <input type="hidden" id="conversation-id" value="{{ conversation.id }}">
    <input type="hidden" id="other-user-id" value="{{ other_user.id }}">
    <input type="hidden" id="other-username" value="{{ other_user.username }}">
{% endblock %}

{% block scripts %}
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Global variables
        let socket;
        let currentConversationId = document.getElementById('conversation-id').value;
        let currentOtherUserId = document.getElementById('other-user-id').value;
        let currentOtherUsername = document.getElementById('other-username').value;
        let currentUserId = null;
        let currentUsername = '{{ current_user.username }}';
        let mediaRecorder;
        let audioChunks = [];
        let recordingTimer = null;
        let recordingSeconds = 0;
        let typingTimer = null;
        let typingIndicatorTimer = null;
        let isOnline = navigator.onLine;
        let pendingMessages = new Map(); // Store pending messages with their temporary IDs
        let syncInProgress = false;
        
        // DOM elements
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const micBtn = document.getElementById('mic-btn');
        const audioControls = document.getElementById('audio-controls');
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerEl = document.getElementById('recording-timer');
        const stopRecordingBtn = document.getElementById('stop-recording-btn');
        const deleteConversationBtn = document.getElementById('delete-conversation-btn');
        const userActivityIndicator = document.getElementById('user-activity-indicator');
        const offlineIndicator = document.getElementById('offline-indicator');
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            checkAuthStatus();
            setupNetworkMonitoring();
            loadPendingMessages();
        });
        
        function setupNetworkMonitoring() {
            // Listen for online/offline events
            window.addEventListener('online', function() {
                console.log('Connection restored');
                isOnline = true;
                updateOnlineStatus();
                syncPendingMessages();
            });
            
            window.addEventListener('offline', function() {
                console.log('Connection lost');
                isOnline = false;
                updateOnlineStatus();
            });
            
            // Initial status update
            updateOnlineStatus();
        }
        
        function updateOnlineStatus() {
            if (isOnline) {
                offlineIndicator.style.display = 'none';
            } else {
                offlineIndicator.style.display = 'block';
            }
        }
        
        function checkAuthStatus() {
            fetch('/check_auth', {
                credentials: 'include'
            })
            .then(response => response.json())
            .then(data => {
                if (data.authenticated) {
                    currentUserId = data.user_id;
                    initializeSocket();
                    loadMessages();
                    loadUserStatus();
                    
                    // Set up event listeners
                    setupChatEvents();
                } else {
                    window.location.href = '/login';
                }
            })
            .catch(error => {
                console.error('Auth check error:', error);
                // If offline and auth fails, try to continue with cached data
                if (!isOnline) {
                    currentUserId = 'offline-user'; // Temporary ID for offline mode
                    loadMessages();
                    setupChatEvents();
                } else {
                    window.location.href = '/login';
                }
            });
        }
        
        function initializeSocket() {
            // Connect to Socket.IO server
            socket = io({
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            // Socket event handlers
            socket.on('connect', function() {
                console.log('Connected to server');
                isOnline = true;
                updateOnlineStatus();
                
                // Join the conversation room
                socket.emit('join_conversation', {conversation_id: currentConversationId});
                
                // Sync pending messages
                syncPendingMessages();
                
                // Send periodic activity pings to stay online
                setInterval(() => {
                    if (isOnline) {
                        socket.emit('user_activity');
                    }
                }, 15000);
            });
            
            socket.on('new_message', function(data) {
                if (data.conversation_id === currentConversationId) {
                    addMessageToChat(data);
                    // If this is a pending message we sent, remove it from pending
                    if (data.temp_id && pendingMessages.has(data.temp_id)) {
                        pendingMessages.delete(data.temp_id);
                        savePendingMessages();
                    }
                }
            });
            
            socket.on('message_status_update', function(data) {
                updateMessageStatus(data.message_id, data.status);
            });
            
            socket.on('user_status', function(data) {
                if (data.user_id == currentOtherUserId) {
                    updateChatStatusIndicator(data.status);
                }
            });
            
            socket.on('message_deleted', function(data) {
                if (data.conversation_id === currentConversationId) {
                    const messageElement = document.querySelector(`.message[data-message-id="${data.message_id}"]`);
                    if (messageElement) {
                        messageElement.remove();
                    }
                }
            });
            
            socket.on('user_typing', function(data) {
                if (data.conversation_id === currentConversationId && data.user_id == currentOtherUserId) {
                    showUserActivityIndicator(data.is_typing ? 'typing' : null);
                }
            });
            
            socket.on('user_recording', function(data) {
                if (data.conversation_id === currentConversationId && data.user_id == currentOtherUserId) {
                    showUserActivityIndicator(data.is_recording ? 'recording' : null);
                }
            });
            
            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                isOnline = false;
                updateOnlineStatus();
            });
            
            socket.on('reconnect', function() {
                console.log('Reconnected to server');
                isOnline = true;
                updateOnlineStatus();
                socket.emit('join_conversation', {conversation_id: currentConversationId});
                syncPendingMessages();
            });
        }
        
        function loadMessages() {
            fetch(`/messages/${currentConversationId}`, {
                credentials: 'include'
            })
            .then(response => {
                if (!response.ok) {
                    if (!isOnline) {
                        // If offline, try to load from local storage
                        return loadMessagesFromStorage();
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(messages => {
                chatMessages.innerHTML = '';
                
                if (messages.length === 0) {
                    chatMessages.innerHTML = `
                        <div class="empty-chat">
                            <p>No messages yet. Start the conversation!</p>
                        </div>
                    `;
                } else {
                    messages.forEach(addMessageToChat);
                }
                
                // Scroll to bottom
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Save messages to local storage for offline access
                saveMessagesToStorage(messages);
            })
            .catch(error => {
                console.error('Error loading messages:', error);
                if (!isOnline) {
                    loadMessagesFromStorage();
                } else if (error.message.includes('401') || error.message.includes('403')) {
                    alert('Session expired. Please log in again.');
                    window.location.href = '/login';
                }
            });
        }
        
        function loadMessagesFromStorage() {
            const storedMessages = localStorage.getItem(`messages_${currentConversationId}`);
            if (storedMessages) {
                const messages = JSON.parse(storedMessages);
                chatMessages.innerHTML = '';
                messages.forEach(addMessageToChat);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }
        
        function saveMessagesToStorage(messages) {
            localStorage.setItem(`messages_${currentConversationId}`, JSON.stringify(messages));
        }
        
        function loadUserStatus() {
            if (!isOnline) return;
            
            fetch(`/users/status`, {
                credentials: 'include'
            })
            .then(response => response.json())
            .then(data => {
                if (data[currentOtherUserId]) {
                    updateChatStatusIndicator(data[currentOtherUserId].status);
                }
            })
            .catch(error => {
                console.error('Error loading user status:', error);
            });
        }
        
        function updateChatStatusIndicator(status) {
            const statusElement = document.getElementById('current-chat-status');
            if (statusElement) {
                statusElement.textContent = status === 'online' ? 'online' : 
                                          status === 'recently online' ? 'recently online' : 'offline';
                statusElement.className = `chat-status ${status}`;
            }
        }
        
        function showUserActivityIndicator(activityType) {
            if (typingIndicatorTimer) {
                clearTimeout(typingIndicatorTimer);
            }
            
            if (activityType) {
                if (activityType === 'typing') {
                    userActivityIndicator.textContent = `${currentOtherUsername} is typing...`;
                    userActivityIndicator.style.display = 'block';
                } else if (activityType === 'recording') {
                    userActivityIndicator.textContent = `${currentOtherUsername} is recording an audio message...`;
                    userActivityIndicator.style.display = 'block';
                }
                
                typingIndicatorTimer = setTimeout(() => {
                    userActivityIndicator.style.display = 'none';
                }, 3000);
            } else {
                userActivityIndicator.style.display = 'none';
            }
        }
        
        function setupChatEvents() {
            // Microphone button for recording
            micBtn.addEventListener('click', function() {
                if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                    startRecording();
                } else {
                    stopRecording();
                }
            });
            
            // Stop recording button
            stopRecordingBtn.addEventListener('click', function() {
                stopRecording();
            });
            
            // Send message button
            sendBtn.addEventListener('click', sendMessage);
            
            // Send message on Enter key
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Typing indicators
            messageInput.addEventListener('input', function() {
                if (messageInput.value.length > 0) {
                    if (isOnline) {
                        socket.emit('typing_start', {conversation_id: currentConversationId});
                    }
                    
                    if (typingTimer) {
                        clearTimeout(typingTimer);
                    }
                    
                    typingTimer = setTimeout(() => {
                        if (isOnline) {
                            socket.emit('typing_stop', {conversation_id: currentConversationId});
                        }
                    }, 1000);
                } else {
                    if (isOnline) {
                        socket.emit('typing_stop', {conversation_id: currentConversationId});
                    }
                }
            });
            
            // Delete conversation button
            deleteConversationBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to delete this conversation? All messages will be deleted.')) {
                    fetch(`/delete_conversation/${currentConversationId}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Clear local storage
                            localStorage.removeItem(`messages_${currentConversationId}`);
                            localStorage.removeItem(`pending_messages_${currentConversationId}`);
                            window.location.href = '/';
                        } else {
                            alert('Error deleting conversation');
                        }
                    })
                    .catch(error => {
                        console.error('Error deleting conversation:', error);
                        alert('Error deleting conversation. Please try again.');
                    });
                }
            });
        }
        
        function addMessageToChat(message) {
            const emptyChat = chatMessages.querySelector('.empty-chat');
            if (emptyChat) {
                emptyChat.remove();
            }
            
            const messageElement = document.createElement('div');
            const isCurrentUser = message.user_id === currentUserId;
            messageElement.className = `message ${isCurrentUser ? 'sent' : 'received'}`;
            messageElement.setAttribute('data-message-id', message.id || message.temp_id);
            
            const timestamp = new Date(message.timestamp);
            const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let messageContent = '';
            
            if (message.type === 'text') {
                messageContent = `
                    <div class="message-content">${message.content}</div>
                `;
            } else if (message.type === 'audio') {
                messageContent = `
                    <div class="message-content audio-message">
                        <audio controls>
                            <source src="${message.content}" type="audio/webm">
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                `;
            }
            
            let statusIndicator = '';
            if (isCurrentUser) {
                if (message.status === 'pending') {
                    statusIndicator = '<span class="message-status pending">üïí</span>';
                } else if (message.status === 'sent') {
                    statusIndicator = '<span class="message-status sent">‚úì</span>';
                } else if (message.status === 'delivered') {
                    statusIndicator = '<span class="message-status delivered">‚úì‚úì</span>';
                } else if (message.status === 'read') {
                    statusIndicator = '<span class="message-status read">‚úì‚úì</span>';
                }
            }
            
            let deleteButton = '';
            if (isCurrentUser && message.id) { // Only allow deletion for messages that have been sent to server
                deleteButton = `<button class="delete-message-btn" data-message-id="${message.id}">Delete</button>`;
            }
            
            messageElement.innerHTML = `
                ${messageContent}
                <div class="message-info">
                    <span class="username">${message.username}</span>
                    <span class="timestamp">${timeString}</span>
                    ${statusIndicator}
                    ${deleteButton}
                </div>
            `;
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            const deleteBtn = messageElement.querySelector('.delete-message-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', function() {
                    const messageId = this.getAttribute('data-message-id');
                    deleteMessage(messageId);
                });
            }
        }
        
        function updateMessageStatus(messageId, status) {
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (messageElement) {
                const statusElement = messageElement.querySelector('.message-status');
                if (statusElement) {
                    statusElement.className = `message-status ${status}`;
                    if (status === 'sent') {
                        statusElement.innerHTML = '‚úì';
                    } else if (status === 'delivered' || status === 'read') {
                        statusElement.innerHTML = '‚úì‚úì';
                    }
                }
            }
        }
        
        function deleteMessage(messageId) {
            fetch(`/delete_message/${messageId}`, {
                method: 'DELETE',
                credentials: 'include'
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('Error deleting message');
                }
            })
            .catch(error => {
                console.error('Error deleting message:', error);
                alert('Error deleting message. Please try again.');
            });
        }
        
        function sendMessage() {
            const message = messageInput.value.trim();
            
            if (message) {
                const tempId = 'temp_' + Date.now();
                const messageData = {
                    temp_id: tempId,
                    content: message,
                    conversation_id: currentConversationId,
                    user_id: currentUserId,
                    username: currentUsername,
                    type: 'text',
                    status: 'pending',
                    timestamp: new Date().toISOString()
                };
                
                // Add to UI immediately
                addMessageToChat(messageData);
                messageInput.value = '';
                
                // Store as pending
                pendingMessages.set(tempId, messageData);
                savePendingMessages();
                
                // Try to send if online
                if (isOnline) {
                    sendMessageToServer(messageData);
                }
                
                // Stop typing indicator
                if (isOnline) {
                    socket.emit('typing_stop', {conversation_id: currentConversationId});
                }
            }
        }
        
        function sendMessageToServer(messageData) {
            if (!isOnline) return;
            
            fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    content: messageData.content,
                    conversation_id: messageData.conversation_id,
                    temp_id: messageData.temp_id
                }),
                credentials: 'include'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update message status in UI
                    updateMessageStatus(messageData.temp_id, 'sent');
                    // Remove from pending
                    pendingMessages.delete(messageData.temp_id);
                    savePendingMessages();
                } else {
                    updateMessageStatus(messageData.temp_id, 'failed');
                }
            })
            .catch(error => {
                console.error('Error sending message:', error);
                updateMessageStatus(messageData.temp_id, 'failed');
            });
        }
        
        function loadPendingMessages() {
            const stored = localStorage.getItem(`pending_messages_${currentConversationId}`);
            if (stored) {
                const pending = JSON.parse(stored);
                pending.forEach(msg => {
                    pendingMessages.set(msg.temp_id, msg);
                    // Only add to UI if it's not already there
                    if (!document.querySelector(`.message[data-message-id="${msg.temp_id}"]`)) {
                        addMessageToChat(msg);
                    }
                });
            }
        }
        
        function savePendingMessages() {
            const pendingArray = Array.from(pendingMessages.values());
            localStorage.setItem(`pending_messages_${currentConversationId}`, JSON.stringify(pendingArray));
        }
        
        function syncPendingMessages() {
            if (!isOnline || syncInProgress || pendingMessages.size === 0) return;
            
            syncInProgress = true;
            const promises = [];
            
            pendingMessages.forEach((message, tempId) => {
                promises.push(
                    fetch('/send_message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            content: message.content,
                            conversation_id: message.conversation_id,
                            temp_id: tempId
                        }),
                        credentials: 'include'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            pendingMessages.delete(tempId);
                            updateMessageStatus(tempId, 'sent');
                        }
                    })
                    .catch(error => {
                        console.error('Error syncing message:', error);
                    })
                );
            });
            
            Promise.all(promises).then(() => {
                syncInProgress = false;
                savePendingMessages();
            });
        }
        
        function startRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Your browser doesn't support audio recording");
                return;
            }
            
            if (isOnline) {
                socket.emit('recording_start', {conversation_id: currentConversationId});
            }
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    audioChunks = [];
                    mediaRecorder = new MediaRecorder(stream);
                    
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendAudioMessage(audioBlob);
                        resetRecordingUI();
                        
                        if (isOnline) {
                            socket.emit('recording_stop', {conversation_id: currentConversationId});
                        }
                    };
                    
                    mediaRecorder.start();
                    showRecordingUI();
                })
                .catch(error => {
                    console.error('Error accessing microphone:', error);
                    alert('Error accessing microphone. Please ensure you have granted permission.');
                    
                    if (isOnline) {
                        socket.emit('recording_stop', {conversation_id: currentConversationId});
                    }
                });
        }
        
        function showRecordingUI() {
            micBtn.classList.add('recording');
            audioControls.style.display = 'flex';
            recordingSeconds = 0;
            recordingTimerEl.textContent = '0s';
            
            recordingTimer = setInterval(() => {
                recordingSeconds++;
                recordingTimerEl.textContent = `${recordingSeconds}s`;
            }, 1000);
        }
        
        function resetRecordingUI() {
            micBtn.classList.remove('recording');
            audioControls.style.display = 'none';
            clearInterval(recordingTimer);
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }
        
        function sendAudioMessage(audioBlob) {
            const tempId = 'temp_audio_' + Date.now();
            const messageData = {
                temp_id: tempId,
                content: URL.createObjectURL(audioBlob),
                conversation_id: currentConversationId,
                user_id: currentUserId,
                username: currentUsername,
                type: 'audio',
                status: 'pending',
                timestamp: new Date().toISOString()
            };
            
            // Add to UI immediately
            addMessageToChat(messageData);
            
            // Store as pending
            pendingMessages.set(tempId, messageData);
            savePendingMessages();
            
            // Try to send if online
            if (isOnline) {
                const formData = new FormData();
                formData.append('audio', audioBlob);
                formData.append('temp_id', tempId);
                
                fetch(`/upload_audio/${currentConversationId}`, {
                    method: 'POST',
                    body: formData,
                    credentials: 'include'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateMessageStatus(tempId, 'sent');
                        pendingMessages.delete(tempId);
                        savePendingMessages();
                    } else {
                        updateMessageStatus(tempId, 'failed');
                    }
                })
                .catch(error => {
                    console.error('Error sending audio:', error);
                    updateMessageStatus(tempId, 'failed');
                });
            }
        }
    </script>
{% endblock %}